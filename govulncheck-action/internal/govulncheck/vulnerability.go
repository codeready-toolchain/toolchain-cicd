package govulncheck

import (
	"fmt"
	"io"
	"log/slog"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/codeready-toolchain/toolchain-cicd/govulncheck-action/internal/configuration"
)

// getTracesInfo gets all the locations where the vulnerability is presented
// <file>:<line>:<column>
// example: pkg/configuration/config.go:95:26
func getTracesInfo(findings []*Finding) []string {
	traceInfo := make([]string, 0)
	for _, f := range findings {
		// the location of the file is presented on the last item of the trace
		trace := f.Trace[len(f.Trace)-1]
		info := fmt.Sprintf("%s:%s:%s\n", trace.Position.Filename, strconv.Itoa(trace.Position.Line), strconv.Itoa(trace.Position.Column))

		traceInfo = append(traceInfo, info)
	}
	return traceInfo
}

func isStdLib(module string) bool {
	return module == "stdlib"
}

func getVersion(isStdLib bool, msg, pkg, version string) string {
	// if there is no version, it means there is no available fix
	if version == "" {
		return fmt.Sprintf("%s: N/A", msg)
	}
	if isStdLib {
		// if it is stdlib, means that the vulnerability is presented in the go version
		// ex: go1.22.12
		version = "go" + strings.TrimPrefix(version, "v")
	}
	return fmt.Sprintf("%s: %s@%s", msg, pkg, version)
}

func getVulnerabilities(rawReport []byte) ([]*Vulnerability, error) {
	var vulns []*Vulnerability

	report, err := parseReport(rawReport)
	if err != nil {
		return nil, fmt.Errorf("failed to parse: %w", err)
	}

	for id := range report.Finding {
		isStandard := isStdLib(report.Finding[id][0].Trace[0].Module)
		// the target package is presented in the first item of the trace
		pkg := report.Finding[id][0].Trace[0].Package

		vulns = append(vulns, &Vulnerability{
			ID:       id,
			Summary:  report.OSV[id].Summary,
			MoreInfo: report.OSV[id].DatabaseSpecific.URL,
			FoundIn:  getVersion(isStandard, "Found in", pkg, report.Finding[id][0].Trace[0].Version),
			FixedIn:  getVersion(isStandard, "Fixed in", pkg, report.Finding[id][0].FixedVersion),
			Traces:   getTracesInfo(report.Finding[id]),
		})
	}

	sort.Slice(vulns, func(i, j int) bool {
		return vulns[i].ID < vulns[j].ID
	})

	return vulns, nil
}

func pruneIgnoredVulns(logger *slog.Logger, detected []*Vulnerability, ignored []*configuration.Vulnerability) []*Vulnerability {
	vulns := make([]*Vulnerability, 0, len(detected))
loop:
	for _, d := range detected {
		for _, i := range ignored {
			if d.ID == i.ID {
				if i.SilenceUntil.Before(time.Now()) {
					// if `silence-until` date has passed, do not ignore it anymore
					logger.Warn("vulnerability not ignored: `silence-until` date has passed, please check if there is an available fix", "vuln-id", i.ID, "silence-until", i.SilenceUntil.Format(time.RFC3339))
					vulns = append(vulns, d)
					continue loop
				}
				continue loop
			}
		}
		vulns = append(vulns, d)
	}
	return vulns
}

func listOutdatedVulns(detected []*Vulnerability, ignored []*configuration.Vulnerability) []*configuration.Vulnerability {
	vulns := make([]*configuration.Vulnerability, 0, len(ignored))
loop:
	for _, i := range ignored {
		for _, d := range detected {
			if d.ID == i.ID {
				continue loop
			}
		}
		vulns = append(vulns, i)
	}
	return vulns
}

func PrintVulnerabilities(stdout io.Writer, vulns []*Vulnerability) {
	for i, vuln := range vulns {
		fmt.Fprintf(stdout, "Vulnerability #%d: %s\n", i+1, vuln.ID)
		fmt.Fprintf(stdout, "  %s\n", vuln.Summary)
		fmt.Fprintf(stdout, "  More info: %s\n", vuln.MoreInfo)
		fmt.Fprintf(stdout, "  %s\n", vuln.FoundIn)
		fmt.Fprintf(stdout, "  %s\n", vuln.FixedIn)
		fmt.Fprintln(stdout, "  Example traces found:")
		for idx, info := range removeDuplicates(vuln.Traces) {
			fmt.Fprintf(stdout, "    #%d: %s", idx+1, info)
		}
		fmt.Println("")
		fmt.Fprintln(stdout, "if this vulnerability cannot be fixed, add the following entry in your exclusion file:")
		fmt.Fprintf(stdout, "  # %s\n", vuln.Summary)
		fmt.Fprintf(stdout, "  # %s\n", vuln.FoundIn)
		fmt.Fprintf(stdout, "  # %s\n", vuln.FixedIn)
		fmt.Fprintf(stdout, "  - id: %s\n", vuln.ID)
		fmt.Fprintf(stdout, "    info: %s\n", vuln.MoreInfo)
		fmt.Fprintf(stdout, "    silence-until: %s\n", time.Now().Add(30*24*time.Hour).Format("2006-01-02")) // silence for 30 days

		fmt.Println("")
	}
}

func PrintOutdatedVulnerabilities(stdout io.Writer, vulns []*configuration.Vulnerability) {
	for _, vuln := range vulns {
		fmt.Fprintf(stdout, "Vulnerability %s is outdated (must be removed from config)\n", vuln.ID)
	}
}

func removeDuplicates(slice []string) []string {
	allKeys := make(map[string]bool)
	duplicatesRemoved := []string{}
	for _, item := range slice {
		if _, value := allKeys[item]; !value {
			allKeys[item] = true
			duplicatesRemoved = append(duplicatesRemoved, item)
		}
	}
	return duplicatesRemoved
}
