package govulncheck

import (
	"fmt"
	"log"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/codeready-toolchain/toolchain-cicd/govulncheck-action/internal/configuration"
)

// getTracesInfo gets all the locations where the vulnerability is presented
// <file>:<line>:<column>
// example: pkg/configuration/config.go:95:26
func getTracesInfo(findings []*Finding) []string {
	traceInfo := make([]string, 0)
	for _, f := range findings {
		// the location of the file is presented on the last item of the trace
		trace := f.Trace[len(f.Trace)-1]
		info := fmt.Sprintf("%s:%s:%s\n", trace.Position.Filename, strconv.Itoa(trace.Position.Line), strconv.Itoa(trace.Position.Column))

		traceInfo = append(traceInfo, info)
	}
	return traceInfo
}

func isStdLib(module string) bool {
	return module == "stdlib"
}

func getVersion(isStdLib bool, msg, pkg, version string) string {
	// if there is no version, it means there is no available fix
	if version == "" {
		return fmt.Sprintf("%s: N/A", msg)
	}
	if isStdLib {
		// if it is stdlib, means that the vulnerability is presented in the go version
		// ex: go1.22.12
		version = "go" + strings.TrimPrefix(version, "v")
	}
	return fmt.Sprintf("%s: %s@%s", msg, pkg, version)
}

func getVulnerabilities(rawReport []byte) ([]*Vulnerability, error) {
	var vulns []*Vulnerability

	report, err := parseReport(rawReport)
	if err != nil {
		return nil, fmt.Errorf("failed to parse: %w", err)
	}

	for id := range report.Finding {
		isStandard := isStdLib(report.Finding[id][0].Trace[0].Module)
		// the target package is presented in the first item of the trace
		pkg := report.Finding[id][0].Trace[0].Package

		vulns = append(vulns, &Vulnerability{
			ID:       id,
			Summary:  report.OSV[id].Summary,
			MoreInfo: report.OSV[id].DatabaseSpecific.URL,
			FoundIn:  getVersion(isStandard, "Found in", pkg, report.Finding[id][0].Trace[0].Version),
			FixedIn:  getVersion(isStandard, "Fixed in", pkg, report.Finding[id][0].FixedVersion),
			Traces:   getTracesInfo(report.Finding[id]),
		})
	}

	sort.Slice(vulns, func(i, j int) bool {
		return vulns[i].ID < vulns[j].ID
	})

	return vulns, nil
}

func shouldBeIgnored(logger *log.Logger, ignored []*configuration.Vulnerability, vulnID string) bool {
	for _, ignore := range ignored {
		if vulnID == ignore.ID {
			if ignore.SilenceUntil.Before(time.Now()) {
				// if `silence-until` date has passed, do not ignore it anymore
				logger.Printf("vulnerability '%s' not ignored: `silence-until` date has passed, please check if there is an available fix", vulnID)
				return false
			}
			return true
		}
	}
	return false
}

func pruneIgnoredVulns(logger *log.Logger, detected []*Vulnerability, ignored []*configuration.Vulnerability) []*Vulnerability {
	vulns := make([]*Vulnerability, 0, len(detected))
	for _, d := range detected {
		if !shouldBeIgnored(logger, ignored, d.ID) {
			vulns = append(vulns, d)
		}

	}
	return vulns
}

func removeDuplicates(slice []string) []string {
	allKeys := make(map[string]bool)
	duplicatesRemoved := []string{}
	for _, item := range slice {
		if _, value := allKeys[item]; !value {
			allKeys[item] = true
			duplicatesRemoved = append(duplicatesRemoved, item)
		}
	}

	return duplicatesRemoved

}

func PrintVulnerabilities(logger *log.Logger, vulns []*Vulnerability) {
	for i, vuln := range vulns {
		logger.Printf("Vulnerability #%d: %s\n", i+1, vuln.ID)
		logger.Printf("  %s\n", vuln.Summary)
		logger.Printf("  More info: %s\n", vuln.MoreInfo)
		logger.Printf("  %s\n", vuln.FoundIn)
		logger.Printf("  %s\n", vuln.FixedIn)
		logger.Println("  Example traces found:")
		for idx, info := range removeDuplicates(vuln.Traces) {
			logger.Printf("    #%d: %s", idx+1, info)
		}
		fmt.Println("")
		logger.Println("if this vulnerability cannot be fixed, add the following entry in your exclusion file:")
		logger.Printf("  # %s\n", vuln.Summary)
		logger.Printf("  # %s\n", vuln.FoundIn)
		logger.Printf("  # %s\n", vuln.FixedIn)
		logger.Printf("  - id: %s\n", vuln.ID)
		logger.Printf("    info: %s\n", vuln.MoreInfo)
		logger.Printf("    silence-until: %s\n", time.Now().Add(30*24*time.Hour).Format("2006-01-02")) // silence for 30 days

		fmt.Println("")
	}
}
