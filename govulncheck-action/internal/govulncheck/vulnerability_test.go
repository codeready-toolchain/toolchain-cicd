package govulncheck

import (
	"bytes"
	"log"
	"os"
	"strings"
	"testing"
	"time"

	"github.com/codeready-toolchain/toolchain-cicd/govulncheck-action/internal/configuration"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestGetVulnerabilities(t *testing.T) {
	t.Run("get vulnerabilities", func(t *testing.T) {
		// given
		report, err := os.ReadFile("../testdata/valid_report.json")
		require.NoError(t, err)
		// when
		vulns, err := getVulnerabilities(report)
		// then
		require.NoError(t, err)
		require.Len(t, vulns, 2)
		// case where there is no fix available
		vuln1 := &Vulnerability{
			ID:       "GO-2025-3547",
			Summary:  "Kubernetes kube-apiserver Vulnerable to Race Condition in k8s.io/kubernetes",
			MoreInfo: "https://pkg.go.dev/vuln/GO-2025-3547",
			FoundIn:  "Found in: k8s.io/kubernetes/pkg/features@v1.30.10",
			FixedIn:  "Fixed in: N/A",
			Traces:   []string{"main.go:46:2\n", "pkg/cri/containers.go:39:52\n"},
		}
		// case where the vuln is on go version
		vuln2 := &Vulnerability{
			ID:       "GO-2025-3563",
			Summary:  "Request smuggling due to acceptance of invalid chunked data in net/http",
			MoreInfo: "https://pkg.go.dev/vuln/GO-2025-3563",
			FoundIn:  "Found in: net/http/internal@go1.22.12",
			FixedIn:  "Fixed in: net/http/internal@go1.23.8",
			Traces:   []string{"pkg/configuration/config.go:95:26\n"},
		}
		assert.Equal(t, vuln1, vulns[0])
		assert.Equal(t, vuln2, vulns[1])
	})

	t.Run("returns error and empty slice for invalid report", func(t *testing.T) {
		// given
		report := []byte(`{`)
		// when
		vulns, err := getVulnerabilities(report)
		// then
		require.Error(t, err)
		require.Empty(t, vulns)
	})
}

func TestPruneIgnoreVulns(t *testing.T) {
	logger := log.Default()

	detectedVulns := []*Vulnerability{
		{
			ID: "GO-2025-0001",
		},
		{
			ID: "GO-2025-0002",
		},
		{
			ID: "GO-2025-0003",
		},
	}

	t.Run("ignore all vulns", func(t *testing.T) {
		// given
		ignoredVulns := []*configuration.Vulnerability{
			{
				ID:           "GO-2025-0001",
				SilenceUntil: time.Now().Add(24 * time.Hour),
				Info:         "https://pkg.go.dev/vuln/GO-2025-0001",
			},
			{
				ID:           "GO-2025-0002",
				SilenceUntil: time.Now().Add(24 * time.Hour),
				Info:         "https://pkg.go.dev/vuln/GO-2025-0002",
			},
			{
				ID:           "GO-2025-0003",
				SilenceUntil: time.Now().Add(24 * time.Hour),
				Info:         "https://pkg.go.dev/vuln/GO-2025-0003",
			},
		}
		// when
		vulns := pruneIgnoredVulns(logger, detectedVulns, ignoredVulns)
		// then
		assert.Empty(t, vulns)
	})

	t.Run("ignore first vuln", func(t *testing.T) {
		// given
		ignoredVulns := []*configuration.Vulnerability{
			{
				ID:           "GO-2025-0001",
				SilenceUntil: time.Now().Add(24 * time.Hour),
				Info:         "https://pkg.go.dev/vuln/GO-2025-0001",
			},
		}
		// when
		vulns := pruneIgnoredVulns(logger, detectedVulns, ignoredVulns)
		// then
		require.Len(t, vulns, 2)
		assert.Equal(t, "GO-2025-0002", vulns[0].ID)
		assert.Equal(t, "GO-2025-0003", vulns[1].ID)
	})

	t.Run("ignore first and last vulns", func(t *testing.T) {
		// given
		ignoredVulns := []*configuration.Vulnerability{
			{
				ID:           "GO-2025-0001",
				SilenceUntil: time.Date(2200, 5, 10, 0, 0, 0, 0, time.UTC),
				Info:         "https://pkg.go.dev/vuln/GO-2025-0001",
			},

			{
				ID:           "GO-2025-0003",
				SilenceUntil: time.Date(2200, 5, 10, 0, 0, 0, 0, time.UTC),
				Info:         "https://pkg.go.dev/vuln/GO-2025-0003",
			},
		}
		// when
		vulns := pruneIgnoredVulns(logger, detectedVulns, ignoredVulns)
		// then
		require.Len(t, vulns, 1)
		assert.Equal(t, "GO-2025-0002", vulns[0].ID)
	})

	t.Run("need to revaluate vulnerability", func(t *testing.T) {
		// given
		ignoredVulns := []*configuration.Vulnerability{
			{
				ID:           "GO-2025-0001",
				SilenceUntil: time.Date(2020, 5, 10, 0, 0, 0, 0, time.UTC),
				Info:         "https://pkg.go.dev/vuln/GO-2025-0001",
			},
		}
		// when
		vulns := pruneIgnoredVulns(logger, detectedVulns, ignoredVulns)
		// then
		require.Len(t, vulns, 3)
		assert.Equal(t, "GO-2025-0001", vulns[0].ID)
		assert.Equal(t, "GO-2025-0002", vulns[1].ID)
		assert.Equal(t, "GO-2025-0003", vulns[2].ID)
	})

}

func TestRemoveDuplicates(t *testing.T) {
	// given
	tests := []struct {
		name     string
		input    []string
		expected []string
	}{
		{
			name:     "all the same",
			input:    []string{"a", "a", "a"},
			expected: []string{"a"},
		},
		{
			name:     "no duplicates",
			input:    []string{"a", "b", "c"},
			expected: []string{"a", "b", "c"},
		},
		{
			name:     "with duplicates",
			input:    []string{"a", "a", "b", "c", "b"},
			expected: []string{"a", "b", "c"},
		},
	}

	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			// when
			got := removeDuplicates(test.input)
			// then
			require.Equal(t, test.expected, got)
		})
	}
}

func TestPrintVulnerabilities(t *testing.T) {
	// given
	var buf bytes.Buffer
	logger := log.New(&buf, "", 0)

	vulns := []*Vulnerability{
		{
			ID:       "GO-2025-0001",
			Summary:  "summary",
			MoreInfo: "https://pkg.go.dev/vuln/GO-2025-0001",
			FoundIn:  "Found in: pkg/pkg1@v1.0.0",
			FixedIn:  "Fixed in: pkg/pkg1@v1.0.1",
			Traces: []string{
				"file1.go:10:2",
				"file2.go:21:5",
				"file1.go:10:2",
			},
		},
		{
			ID:       "GO-2025-0002",
			Summary:  "summary",
			MoreInfo: "https://pkg.go.dev/vuln/GO-2025-0002",
			FoundIn:  "Found in: pkg/pkg2@v2.0.0",
			FixedIn:  "Fixed in: pkg/pkg2@v2.0.1",
			Traces: []string{
				"file2.go:21:5",
			},
		},
	}

	// when
	PrintVulnerabilities(logger, vulns)

	out := buf.String()

	// then
	assert.Contains(t, out, "Vulnerability #1: GO-2025-0001")
	assert.Contains(t, out, "summary")
	assert.Contains(t, out, "More info: https://pkg.go.dev/vuln/GO-2025-0001")
	assert.Contains(t, out, "Found in: pkg/pkg1@v1.0.0")
	assert.Contains(t, out, "Fixed in: pkg/pkg1@v1.0.1")
	assert.Equal(t, 1, strings.Count(out, "file1.go:10:2"))
	assert.Contains(t, out, "#1: file1.go:10:2")
	assert.Contains(t, out, "#2: file2.go:21:5")

	assert.Contains(t, out, "Vulnerability #2: GO-2025-0002")
	assert.Contains(t, out, "summary")
	assert.Contains(t, out, "More info: https://pkg.go.dev/vuln/GO-2025-0002")
	assert.Contains(t, out, "Found in: pkg/pkg2@v2.0.0")
	assert.Contains(t, out, "Fixed in: pkg/pkg2@v2.0.1")
	assert.Contains(t, out, "#1: file2.go:21:5")
}
